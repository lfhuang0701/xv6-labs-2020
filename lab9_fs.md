# lab9.1 bigfile

## 实验内容

未修改的Xv6 文件系统中，inode包含12个直接块号和一个间接块号（用一个数组维护，这里的块号实际指的是数据块地址），间接块可包含256个块号，因此一共为268个块，文件大小268*BSIZE字节。

更改文件系统代码，将一个直接块用作二级间接块，一个二级间接块可包含`256*256`个块地址，因此一个文件大小最大可为`256*256+256+11`个块的大小，实现了bigfile

主要更改的是块分配器（bmap函数），使其能够通过所需的块号返回其块地址，修改块分配器，使其能够支持二级间接块。

更改itrunc函数，使其释放与inode关联的所有磁盘数据块

## 知识点

1. 本次实验使Xv6支持大文件，如何实现的？
   具体就是更改inode结构，因为inode包含13个块编号，这13个块编号指向13个block，未修改之前默认前12个块编号直接指向文件的前12个block，最后一个块编号指向一个间接块，这个间接块记录了256个块编号，即又指向其他256个block，因此未修改前文件最大包含268个block，也即256k大小；现在拿出一个直接块作为一个二级间接块，这个二级间接块又包含256个间接块编号，每个间接块又记录256个block编号，这样文件总大小就为256*256 + 256 + 11 个块大小，即大约64M；具体如何索引就是根据块修改块分配器，使其支持索引逻辑块号大于267的block
2. 实验中使用到的几个函数 bread（）：从磁盘读取指定的块到缓存中；bwrite（）：将块缓存写入磁盘；bfree（）：释放磁盘块；brelse（）：释放块缓存

## 实验流程

1. 更改NDIRECT（直接块）的宏定义，减少一个直接块数量，将减少的块用作二级间接块。相应的需要更改struct inode中addrs[ ]的声明（file.h），和struct dinode addrs[ ]的声明（fs.h）
2. 修改块分配器函数（bmap），添加使用逻辑块号找出二级间接块内数据块的代码
3. 修改itrunc函数，添加释放二级间接块所包含的数据块的代码

## 遇到的问题

1. 程序运行后，文件大小最大仅仅为268个block，说明二级索引块没有起作用检查时发现是因为没有修改文件最大容量的宏定义MAXFILE，可能导致测试程序写入文件时发现偏移量大于最大容量直接返回错误。
