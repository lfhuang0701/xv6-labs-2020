# lab9.1 bigfile

## 实验内容

未修改的Xv6 文件系统中，inode包含12个直接块号和一个间接块号（用一个数组维护，这里的块号实际指的是数据块地址），间接块可包含256个块号，因此一共为268个块，文件大小268*BSIZE字节。

更改文件系统代码，将一个直接块用作二级间接块，一个二级间接块可包含`256*256`个块地址，因此一个文件大小最大可为`256*256+256+11`个块的大小，实现了bigfile

主要更改的是块分配器（bmap函数），使其能够通过所需的块号返回其块地址，修改块分配器，使其能够支持二级间接块。

更改itrunc函数，使其释放与inode关联的所有磁盘数据块

## 知识点

1. 本次实验使Xv6支持大文件，如何实现的？
   具体就是更改inode结构，因为inode包含13个块编号，这13个块编号指向13个block，未修改之前默认前12个块编号直接指向文件的前12个block，最后一个块编号指向一个间接块，这个间接块记录了256个块编号，即又指向其他256个block，因此未修改前文件最大包含268个block，也即256k大小；现在拿出一个直接块作为一个二级间接块，这个二级间接块又包含256个间接块编号，每个间接块又记录256个block编号，这样文件总大小就为256*256 + 256 + 11 个块大小，即大约64M；具体如何索引就是根据块修改块分配器，使其支持索引逻辑块号大于267的block
2. 实验中使用到的几个函数 bread（）：从磁盘读取指定的块到缓存中；bwrite（）：将块缓存写入磁盘；bfree（）：释放磁盘块；brelse（）：释放块缓存

## 实验流程

1. 更改NDIRECT（直接块）的宏定义，减少一个直接块数量，将减少的块用作二级间接块。相应的需要更改struct inode中addrs[ ]的声明（file.h），和struct dinode addrs[ ]的声明（fs.h）
2. 修改块分配器函数（bmap），添加使用逻辑块号找出二级间接块内数据块的代码
3. 修改itrunc函数，添加释放二级间接块所包含的数据块的代码

## 遇到的问题

1. 程序运行后，文件大小最大仅仅为268个block，说明二级索引块没有起作用检查时发现是因为没有修改文件最大容量的宏定义MAXFILE，可能导致测试程序写入文件时发现偏移量大于最大容量直接返回错误。

# lab 9.2 Symbolic links

## 知识点及难点

1. 符号链接也就是软链接，类似于硬链接，但硬链接仅限于指向同一个磁盘上的文件，而符号链接可以跨磁盘设备
2. 符号链接文件之间形成死环的问题，解决方法是记录溯源深度，若达到某一阈值就返回错误

## 实验内容

添加系统调用，用来为目标文件创建符号链接，符号链接本身也是一个文件，在文件的第一个数据块存放目标文件的路径名，目标文件可以是普通文件，也可以是符号链接。

## 实验流程

1. 添加sys_symlink系统调用，添加新的文件类型（T_SYMLINK）即符号链接文件，添加文件标志位（O_NOFOLLOW），此标志位用于符号链接，当设置此标志位时，打开符号链接文件不再链接到目标文件，而是直接打开符号链接文件
2. 实现sys_symlink系统调用，symlink（target,  path），创建一个文件，路径名为path，作为符号链接文件链接target，其中target也是路径名；主要过程包括创建inode，把target写入文件（使用inode实现）
3. 修改sys_open，以应对打开符号链接文件的情况，若没有设置O_NOFOLLOW标志位，应该对符号链接进行溯源，即读取文件内第一个数据块保存的target，并试图打开此文件，重复以上操作，直到遇到普通文件或设置了O_NOFOLLOW标志位的符号链接文件。记录溯源深度，若溯源深度达到10，则返回错误，以此应对回环的问题，即符号链接文件之间链接成为一个环
