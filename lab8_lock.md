# lab8.1 Memory allocator(moderate)

## 实验内容

分配内存和释放内存需要频繁使用空闲链表freelist，为防止多进程产生race-condtion，需要为freelist加锁，这样就会由于锁竞争降低运行速率；

现在为降低锁竞争，提高并行性，需要进行进行锁优化，锁优化一般有两种方案，一是更改数据结构，使共享资源私有化，二是改变锁定策略，即用小锁代替大锁，降低锁粒度。

本实验采用第一种方案，即为每个cpu维护一个空闲链表freelist，并为每个cpu的freelist使用单独的锁，这样多进程若运行在多个cpu上，并行执行就不会访问同一个freelist，降低了锁争用；但是还要实现一个功能：当前cpu的freelist为空时，需要从其他cpu的freelist窃取一部分内存。

## 实验流程

1. 在kalloc.c，根据CPU的数量NCPU为每个CPU维护一个空闲链表结构体，其中包括空闲链表和一把自旋锁
2. 在kinit函数内初始化每把锁
3. 在kfree函数内释放内存，并把空闲页放入空闲链表，这里需要先关闭中断，再获取cpuid，根据cpuid获取对应cpu的空闲链表的锁，接着把空白页放入空闲链表头部（头插法），最后释放锁并关闭中断
4. 在kalloc函数内申请内存，这里先关闭中断，获取该cpu的空闲链表的锁，接着判断空闲链表是否为空，若为空，循环访问其他cpu的空闲链表，若不为空，打破循环

## 知识点及问题

1. 在未修改的kalloc和kfree中，没有关闭中断和开启中断这一操作，为什么这里需要加上这两步骤？
   答：因为在修改后需要获取cpuid，并在之后的操作使用cpuid，若不关闭中断，假设在获取cpuid之后，并在加锁之前发生定时器中断导致yiled（），并被调度到另一个cpu上，这时之前获取到的cpuid就会失效，因此在获取cpuid之前需要关闭中断，并在cpuid使用完毕后再次开启中断。
2. 在kalloc中，若进行窃取操作，需要先获取该cpu的锁，再获取其他cpu的锁，这里有可能会产生死锁。比如，cpu1获取锁后窃取cpu2的空白页，需要获取cpu2的锁，而此时cpu2上的进程获取cpu2的锁后窃取cpu1，需要获取cpu1的锁，造成两者互相获取对方的锁，这就造成死锁现象，因此需要改变锁的策略避免发生死锁。
   解决方案是在获取本cpu的锁时不要去获取其他cpu的锁，在kalloc函数中，先关闭中断，再为本cpu加锁，若本cpu的空闲链表为空，就释放本cpu锁，然后去其他cpu偷空白页，这样就避免了获取本cpu的情况下获取其他cpu的锁
3. 注意xv6启动时会执行kinit函数，函数内freerange会释放所有内存，并把空白页放入本cpu（也就是cpu0）的空闲链表中，因此多进程并行执行时，刚开始均会去cpu0偷页，若每次只偷一个空白页，频繁的偷页会影响性能，因此每次偷页时可以偷64个页，形成一个链表，偷页结束后再将偷来的空白页链表加入到本cpu的空白页链表中

# lab 8.2 Bcache(hard)

## 实验内容

原先的设计，Xv6将所有的区块缓存放入一个区块缓冲链表中，多进程使用文件系统时，会通过区块号访问这个区块缓冲链表，因此需要lock，而多进程访问时，由于lock的存在，需要单线程访问，速率大大减慢。

因此，需要进行锁优化，这里更改存放区块缓存的数据结构，采用哈希表，由区块号映射到13个桶（bucket），并为每个桶维护一把锁，多进程通过区块号访问不同的桶时，就可以并行执行，只有访问同一个桶时采用产生锁争用。

此外，如果通过区块号在对应的桶bucket1内没有找到缓冲区时，需要遍历所有的桶，根据LRU（Least-Recently-Used），找出最近最少使用的缓冲区buf，并将该buf从所属桶中删除，放入bucket1中。

## 主要难点

主要难点是死锁问题及不变量问题；

死锁问题是指bget函数中若获取了bucket1的锁，但是没有找到块的buf，需要遍历其他bucket，这里又需要获取其他bucket的锁，这里的情况是获取了bucket1的锁，又尝试获取bucket2的锁，如果此时另一个进程获取了bucket2的锁，又遍历寻找时尝试获取bucket1的锁，此时就会陷入环路死锁。因此这里可以在遍历其他bucket时先释放bucket1的锁，再遍历寻找，若找到了，再获取bucket1的锁进行插入，但是新的问题出现了，若该进程A释放bucket1的锁后，并行执行的另一进程B根据设备号及区块号也找到了bucket1（因为释放锁后，其他进程就可以进入bucket1），那么进程B也会为该块寻找buf，这样的结果就是两个进程为同一个块映射了两个buf，造成错误。这里解决上述问题的方法就是引入一个新的锁search_lock，这个锁用来保护寻找新buf并加入到bucket中这个过程，在释放bucket1的锁后获取search_lock，在遍历其他bucket之前需要再遍历一遍bucket1，是否有块对应的buf（后续会讲为什么这样做），然后遍历其他bucket寻找空闲buf，找到以后先获取bucket1的锁，再将找到的buf插入bucket1，最后释放bucket1的锁，再释放search_lock。遍历之前再寻找一遍是因为如果释放bucket1的锁后，其他进程获取到bucket1的锁，并抢先一步完成了寻找空闲buf并插入的操作，此时bucket1已经有块对应的buf，而之前进程再次获取searrch_lock后，若不进行检查则会造成重复映射的错误。

不变量问题指的是遍历其他bucket时，若找到目标buf，不应该释放对应bucket，直到从该bucket移出后再释放，因为如果提前释放，则找到的目标buf可能会被其他进程用去而失效。

## 遇到的问题

1. 程序运行时卡住,通过printf定位到找到空闲buf再次分配后，返回之前获取buf的睡眠锁，卡在里面的sleep，检查发现错误是设置buf时，引用数错误地设置为0，可能导致没被唤醒，改为1后运行成功
