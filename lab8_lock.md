# lab8.1 Memory allocator(moderate)

## 实验内容

分配内存和释放内存需要频繁使用空闲链表freelist，为防止多进程产生race-condtion，需要为freelist加锁，这样就会由于锁竞争降低运行速率；

现在为降低锁竞争，提高并行性，需要进行进行锁优化，锁优化一般有两种方案，一是更改数据结构，使共享资源私有化，二是改变锁定策略，即用小锁代替大锁，降低锁粒度。

本实验采用第一种方案，即为每个cpu维护一个空闲链表freelist，并为每个cpu的freelist使用单独的锁，这样多进程若运行在多个cpu上，并行执行就不会访问同一个freelist，降低了锁争用；但是还要实现一个功能：当前cpu的freelist为空时，需要从其他cpu的freelist窃取一部分内存。

## 实验流程

1. 在kalloc.c，根据CPU的数量NCPU为每个CPU维护一个空闲链表结构体，其中包括空闲链表和一把自旋锁
2. 在kinit函数内初始化每把锁
3. 在kfree函数内释放内存，并把空闲页放入空闲链表，这里需要先关闭中断，再获取cpuid，根据cpuid获取对应cpu的空闲链表的锁，接着把空白页放入空闲链表头部（头插法），最后释放锁并关闭中断
4. 在kalloc函数内申请内存，这里先关闭中断，获取该cpu的空闲链表的锁，接着判断空闲链表是否为空，若为空，循环访问其他cpu的空闲链表，若不为空，打破循环

## 知识点及问题

1. 在未修改的kalloc和kfree中，没有关闭中断和开启中断这一操作，为什么这里需要加上这两步骤？
   答：因为在修改后需要获取cpuid，并在之后的操作使用cpuid，若不关闭中断，假设在获取cpuid之后，并在加锁之前发生定时器中断导致yiled（），并被调度到另一个cpu上，这时之前获取到的cpuid就会失效，因此在获取cpuid之前需要关闭中断，并在cpuid使用完毕后再次开启中断。
2. 在kalloc中，若进行窃取操作，需要先获取该cpu的锁，再获取其他cpu的锁，这里有可能会产生死锁。比如，cpu1获取锁后窃取cpu2的空白页，需要获取cpu2的锁，而此时cpu2上的进程获取cpu2的锁后窃取cpu1，需要获取cpu1的锁，造成两者互相获取对方的锁，这就造成死锁现象，因此需要改变锁的策略避免发生死锁。
   解决方案是在获取本cpu的锁时不要去获取其他cpu的锁，在kalloc函数中，先关闭中断，再为本cpu加锁，若本cpu的空闲链表为空，就释放本cpu锁，然后去其他cpu偷空白页，这样就避免了获取本cpu的情况下获取其他cpu的锁
3. 注意xv6启动时会执行kinit函数，函数内freerange会释放所有内存，并把空白页放入本cpu（也就是cpu0）的空闲链表中，因此多进程并行执行时，刚开始均会去cpu0偷页，若每次只偷一个空白页，频繁的偷页会影响性能，因此每次偷页时可以偷64个页，形成一个链表，偷页结束后再将偷来的空白页链表加入到本cpu的空白页链表中
